<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Scurd — AI System Design Canvas</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --radius: 12px;
        --accent: #7c3aed;
        --accent-2: #8b5cf6;
        --glass: rgba(255, 255, 255, 0.08);
        --muted: #9aa3b2;
      }
      /* Light theme vars override in .theme-light */
      body {
        margin: 0;
        font-family: Inter, system-ui, Roboto, -apple-system;
        background: #070710;
        color: #e6eef8;
        height: 100vh;
        overflow: hidden;
      }
      .theme-light body,
      .theme-light .app {
        background: #f6f8fb;
        color: #0b1220;
      }
      .app {
        display: grid;
        grid-template-columns: 360px 1fr;
        gap: 18px;
        padding: 18px;
        height: 100vh;
        box-sizing: border-box;
      }
      /* Panels */
      .panel {
        background: rgba(255, 255, 255, 0.02);
        border-radius: 14px;
        padding: 14px;
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.6);
      }
      .left .brand {
        font-weight: 700;
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .muted {
        color: var(--muted);
        font-size: 13px;
      }
      /* Chat */
      .left {
        display: flex;
        flex-direction: column;
      }
      #messages {
        flex: 1;
        overflow: auto;
        padding: 10px;
        border-radius: 10px;
      }
      .msg {
        max-width: 86%;
        padding: 10px;
        border-radius: 10px;
        margin-bottom: 10px;
        line-height: 1.35;
        word-break: break-word;
      }
      .msg.user {
        align-self: flex-end;
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.02),
          rgba(255, 255, 255, 0.01)
        );
      }
      .msg.ai {
        align-self: flex-start;
        background: transparent;
        border: 1px solid rgba(255, 255, 255, 0.03);
      }
      .msg .meta {
        margin-top: 8px;
        color: var(--muted);
        font-size: 13px;
      }
      .chat-controls {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      textarea#prompt {
        width: 100%;
        min-height: 86px;
        padding: 12px;
        border-radius: 10px;
        border: 1px solid rgba(255, 255, 255, 0.04);
        background: transparent;
        color: inherit;
        resize: vertical;
      }
      .send-row {
        display: flex;
        gap: 8px;
        align-items: center;
      }
      .btn {
        padding: 10px 12px;
        border-radius: 10px;
        border: 1px solid rgba(255, 255, 255, 0.04);
        background: transparent;
        color: inherit;
        cursor: pointer;
        font-weight: 600;
      }
      .btn.primary {
        background: linear-gradient(90deg, var(--accent), var(--accent-2));
        color: white;
        border: none;
        box-shadow: 0 10px 30px rgba(124, 58, 237, 0.12);
      }
      .wide-send {
        flex: 1;
      }
      /* Right - canvas */
      .canvas-wrap {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .toolbar {
        display: flex;
        justify-content: space-between;
        gap: 8px;
        align-items: center;
      }
      .controls {
        display: flex;
        gap: 8px;
        align-items: center;
      }
      select,
      input[type="text"] {
        padding: 8px;
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.04);
        background: transparent;
        color: inherit;
      }
      #canvas {
        position: relative;
        border-radius: 12px;
        flex: 1;
        overflow: auto;
        background-color: #070710;
        background-image: linear-gradient(
            90deg,
            rgba(140, 63, 240, 0.02) 1px,
            transparent 1px
          ),
          linear-gradient(rgba(140, 63, 240, 0.02) 1px, transparent 1px);
        background-size: 22px 22px;
        background-position: 0 0, 11px 11px;
      }
      svg.links {
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 4;
      }
      /* node */
      .node {
        position: absolute;
        min-width: 170px;
        padding: 12px;
        border-radius: 12px;
        box-shadow: 0 12px 36px rgba(2, 6, 23, 0.6);
        cursor: grab;
        z-index: 10;
        display: flex;
        flex-direction: column;
        gap: 8px;
        transition: transform 0.12s ease;
      }
      .node .row {
        display: flex;
        align-items: center;
        justify-content: space-between;
      }
      .leftmeta {
        display: flex;
        gap: 12px;
        align-items: center;
      }
      .icon {
        width: 40px;
        height: 40px;
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 700;
        flex-shrink: 0;
        background: rgba(255, 255, 255, 0.04);
      }
      .title {
        font-weight: 700;
      }
      .desc {
        font-size: 13px;
        color: var(--muted);
      }
      .chips {
        display: flex;
        gap: 6px;
        flex-wrap: wrap;
      }
      .chip {
        padding: 6px 10px;
        border-radius: 999px;
        font-size: 12px;
        background: rgba(0, 0, 0, 0.12);
      }
      /* glass dots */
      .dot {
        position: absolute;
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.95),
          rgba(255, 255, 255, 0.6)
        );
        box-shadow: 0 6px 14px rgba(0, 0, 0, 0.25) inset;
        border: 1px solid rgba(255, 255, 255, 0.35);
        cursor: pointer;
        z-index: 12;
      }
      .dot.top {
        left: 50%;
        transform: translateX(-50%);
        top: -6px;
      }
      .dot.bottom {
        left: 50%;
        transform: translateX(-50%);
        bottom: -6px;
      }
      .dot.left {
        top: 50%;
        transform: translateY(-50%);
        left: -6px;
      }
      .dot.right {
        top: 50%;
        transform: translateY(-50%);
        right: -6px;
      }
      .menu-list {
        position: absolute;
        right: 6px;
        top: 34px;
        background: rgba(0, 0, 0, 0.45);
        padding: 8px;
        border-radius: 8px;
        display: none;
        z-index: 60;
        border: 1px solid rgba(255, 255, 255, 0.03);
      }
      .menu-list.show {
        display: block;
      }
      .menu-list button {
        display: block;
        width: 100%;
        padding: 8px;
        border-radius: 8px;
        border: none;
        background: transparent;
        color: inherit;
        text-align: left;
        cursor: pointer;
      }
      /* FAB & modal & minimap */
      .fab {
        position: fixed;
        right: 28px;
        bottom: 28px;
        width: 60px;
        height: 60px;
        border-radius: 50%;
        background: linear-gradient(90deg, var(--accent), var(--accent-2));
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-size: 26px;
        cursor: pointer;
        z-index: 999;
        box-shadow: 0 18px 50px rgba(124, 58, 237, 0.18);
        border: none;
      }
      .fab-menu {
        position: fixed;
        right: 28px;
        bottom: 100px;
        padding: 10px;
        border-radius: 10px;
        background: rgba(0, 0, 0, 0.6);
        z-index: 999;
        display: none;
        flex-direction: column;
        gap: 8px;
      }
      .fab-menu button {
        background: transparent;
        border: 1px solid rgba(255, 255, 255, 0.04);
        padding: 8px 10px;
        border-radius: 8px;
        color: inherit;
      }
      .modal-backdrop {
        position: fixed;
        inset: 0;
        background: rgba(2, 6, 23, 0.6);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
      }
      .modal {
        background: rgba(0, 0, 0, 0.6);
        padding: 16px;
        border-radius: 12px;
        min-width: 420px;
      }
      .minimap {
        position: absolute;
        right: 12px;
        bottom: 12px;
        width: 160px;
        height: 110px;
        border-radius: 8px;
        background: rgba(0, 0, 0, 0.28);
        z-index: 80;
        border: 1px solid rgba(255, 255, 255, 0.03);
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .minimap canvas {
        width: 92%;
        height: 78%;
        border-radius: 6px;
        background: transparent;
      }
      .status {
        position: fixed;
        left: 18px;
        bottom: 18px;
        font-size: 13px;
        color: var(--muted);
      }
      /* label on links */
      .link-label {
        position: absolute;
        padding: 4px 8px;
        border-radius: 8px;
        background: rgba(0, 0, 0, 0.6);
        color: white;
        font-size: 12px;
        pointer-events: auto;
        cursor: pointer;
        transform: translate(-50%, -50%);
        z-index: 20;
      }
      /* responsive */
      @media (max-width: 900px) {
        .app {
          grid-template-columns: 1fr;
        }
        .left {
          order: 2;
        }
        .canvas-wrap {
          order: 1;
        }
        .fab {
          right: 12px;
          bottom: 12px;
        }
      }
      /* light theme override (simple) */
      .theme-light #canvas {
        background-color: #f6f8fb;
        background-image: linear-gradient(
            90deg,
            rgba(0, 0, 0, 0.02) 1px,
            transparent 1px
          ),
          linear-gradient(rgba(0, 0, 0, 0.02) 1px, transparent 1px);
      }
      .theme-light .panel {
        background: #ffffff;
        color: #0b1220;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.06);
      }
      .theme-light .msg.ai {
        background: #f2f4f7;
        border: 1px solid rgba(0, 0, 0, 0.04);
      }
      .theme-light .link-label {
        background: rgba(255, 255, 255, 0.92);
        color: #0b1220;
      }
    </style>
  </head>
  <body class="theme-dark">
    <div class="app">
      <!-- LEFT: Chat -->
      <div class="panel left">
        <div
          style="
            display: flex;
            justify-content: space-between;
            align-items: center;
          "
        >
          <div class="brand">Scurd — System Design Assistant</div>
          <div style="display: flex; gap: 8px; align-items: center">
            <div id="themeToggle" class="btn small">🌙</div>
          </div>
        </div>
        <div class="muted">
          AI assistant & design history — apply AI suggestions to canvas
        </div>

        <div
          id="messages"
          aria-live="polite"
          style="flex: 1; display: flex; flex-direction: column"
        ></div>

        <div class="chat-controls" style="margin-top: 10px">
          <textarea
            id="prompt"
            placeholder="Describe changes, ask for optimizations, or request a new design. (Ctrl+Enter to send)"
          ></textarea>
          <div class="send-row">
            <button id="sendBtn" class="btn primary wide-send">Send</button>
            <button id="clearChat" class="btn">Clear</button>
          </div>
        </div>
      </div>

      <!-- RIGHT: Canvas -->
      <div class="canvas-wrap panel" style="padding: 12px">
        <div class="toolbar">
          <div class="controls">
            <select id="quickAddSelect">
              <option value="">＋ Add node</option>
              <option value="Frontend">Frontend</option>
              <option value="Backend">Backend</option>
              <option value="Database">Database</option>
              <option value="Cache">Cache</option>
              <option value="API Gateway">API Gateway</option>
            </select>
            <button id="quickAddBtn" class="btn">Add</button>
            <button id="moreBtn" class="btn">More…</button>
            <button id="saveBtn" class="btn">Save JSON</button>
            <button id="exportBtn" class="btn">Export PNG</button>
            <button id="recenterBtn" class="btn">Recenter</button>
          </div>
          <div class="controls">
            <button id="zoomIn" class="btn">＋</button>
            <button id="zoomOut" class="btn">－</button>
          </div>
        </div>

        <div id="canvas" tabindex="0">
          <svg id="linksSvg" class="links" preserveAspectRatio="none"></svg>
          <div class="minimap">
            <canvas id="minimapCanvas" width="320" height="200"></canvas>
          </div>
        </div>
      </div>
    </div>

    <button id="fab" class="fab">＋</button>
    <div id="fabMenu" class="fab-menu"></div>

    <!-- More components modal -->
    <div id="moreModal" class="modal-backdrop" style="display: none">
      <div class="modal">
        <h3 style="margin: 0 0 8px 0">More components</h3>
        <div
          id="moreList"
          style="
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            max-height: 420px;
            overflow: auto;
            padding-top: 8px;
          "
        ></div>
        <div style="display: flex; justify-content: flex-end; margin-top: 12px">
          <button id="moreClose" class="btn">Close</button>
        </div>
      </div>
    </div>

    <!-- Add/Edit modal -->
    <div id="editModal" class="modal-backdrop" style="display: none">
      <div class="modal">
        <h3 style="margin: 0 0 8px 0">Add / Edit Node</h3>
        <div style="display: flex; gap: 8px; align-items: center">
          <input
            id="nodeName"
            placeholder="Name"
            style="
              flex: 1;
              padding: 8px;
              border-radius: 8px;
              border: 1px solid rgba(255, 255, 255, 0.04);
            "
          />
          <input
            id="nodeColor"
            type="color"
            value="#6d28d9"
            style="height: 36px; width: 56px; border-radius: 8px; border: none"
          />
        </div>
        <div style="margin-top: 8px"><small class="muted">Logo</small></div>
        <div
          id="logoGrid"
          style="display: flex; gap: 8px; flex-wrap: wrap; margin-top: 8px"
        ></div>
        <div style="margin-top: 8px"><small class="muted">Tech</small></div>
        <div
          id="techGrid"
          style="display: flex; flex-wrap: wrap; gap: 8px; margin-top: 8px"
        ></div>
        <div style="display: flex; justify-content: flex-end; margin-top: 12px">
          <button id="saveNodeBtn" class="btn primary">Save</button>
          <button id="cancelNodeBtn" class="btn" style="margin-left: 8px">
            Cancel
          </button>
        </div>
      </div>
    </div>

    <div id="status" class="status">Ready</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script>
      (function () {
        /* -------------------- CONFIG -------------------- */
        const SAVE_ENDPOINT = "http://localhost:8000/api/save_design"; // autosave endpoint
        const CHAT_ENDPOINT = "http://localhost:8000/api/generate_design"; // chat endpoint (backend handles AI & DB)
        const AUTO_SAVE_DEBOUNCE = 700; // ms

        /* -------------------- STATE -------------------- */
        const canvas = document.getElementById("canvas");
        const linksSvg = document.getElementById("linksSvg");
        const messagesEl = document.getElementById("messages");
        const promptEl = document.getElementById("prompt");
        const sendBtn = document.getElementById("sendBtn");
        const clearChat = document.getElementById("clearChat");
        const saveBtn = document.getElementById("saveBtn");
        const exportBtn = document.getElementById("exportBtn");
        const recenterBtn = document.getElementById("recenterBtn");
        const zoomInBtn = document.getElementById("zoomIn");
        const zoomOutBtn = document.getElementById("zoomOut");
        const quickAddSelect = document.getElementById("quickAddSelect");
        const quickAddBtn = document.getElementById("quickAddBtn");
        const moreBtn = document.getElementById("moreBtn");
        const moreModal = document.getElementById("moreModal");
        const moreClose = document.getElementById("moreClose");
        const moreList = document.getElementById("moreList");
        const fab = document.getElementById("fab");
        const fabMenu = document.getElementById("fabMenu");
        const statusEl = document.getElementById("status");
        const minimapCanvas = document.getElementById("minimapCanvas");
        const themeToggle = document.getElementById("themeToggle");

        const editModal = document.getElementById("editModal");
        const nodeName = document.getElementById("nodeName");
        const nodeColor = document.getElementById("nodeColor");
        const logoGrid = document.getElementById("logoGrid");
        const techGrid = document.getElementById("techGrid");
        const saveNodeBtn = document.getElementById("saveNodeBtn");
        const cancelNodeBtn = document.getElementById("cancelNodeBtn");

        let nodes = {}; // id -> {id,name,color,logo,tech,desc,x,y}
        let links = []; // {id,from:{nodeId,dot},to:{nodeId,dot},label}
        let dragState = null;
        let linkingState = null;
        let tempPath = null;
        let scale = 1;
        let isPanning = false;
        let panStart = null;
        let autoSaveTimer = null;
        let editingNodeId = null;

        const TECHS = [
          "React",
          "Vite",
          "Next.js",
          "FastAPI",
          "Node.js",
          "Postgres",
          "Redis",
          "Nginx",
          "Kafka",
          "S3",
          "Elasticsearch",
          "Prometheus",
          "Grafana",
          "RabbitMQ",
          "Memcached",
          "S3",
        ];
        const LOGOS = [
          "🧩",
          "⚡",
          "🗄️",
          "🌐",
          "🔒",
          "🧠",
          "📡",
          "🧰",
          "🛰️",
          "🗂️",
        ];

        /* -------------------- HELPERS -------------------- */
        function uuid(pref = "n") {
          return pref + Math.random().toString(36).slice(2, 9);
        }
        function q(sel) {
          return document.querySelector(sel);
        }
        function qa(sel) {
          return Array.from(document.querySelectorAll(sel));
        }
        function setStatus(t) {
          statusEl.textContent = t;
        }
        function escapeHtml(s) {
          if (s == null) return "";
          return s.toString().replace(
            /[&<>"']/g,
            (m) =>
              ({
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;",
                '"': "&quot;",
                "'": "&#039;",
              }[m])
          );
        }

        function doAutoSaveDebounced() {
          if (autoSaveTimer) clearTimeout(autoSaveTimer);
          autoSaveTimer = setTimeout(() => {
            postSaveDesign();
          }, AUTO_SAVE_DEBOUNCE);
        }

        /* -------------------- UI: Chat -------------------- */
        function addMessage(text, who = "ai", metaHtml = "") {
          const d = document.createElement("div");
          d.className = "msg " + (who === "user" ? "user" : "ai");
          d.innerHTML = `<div>${escapeHtml(text)}</div>${
            metaHtml ? `<div class="meta">${metaHtml}</div>` : ""
          }`;
          messagesEl.appendChild(d);
          messagesEl.scrollTop = messagesEl.scrollHeight;
          return d;
        }

        sendBtn.addEventListener("click", sendPrompt);
        promptEl.addEventListener("keydown", (e) => {
          if (e.key === "Enter" && (e.ctrlKey || e.metaKey)) sendPrompt();
        });
        clearChat.addEventListener("click", () => (messagesEl.innerHTML = ""));

        async function sendPrompt() {
          const prompt = promptEl.value.trim();
          if (!prompt) return;
          addMessage(prompt, "user");
          promptEl.value = "";

          const thinking = addMessage("Thinking...", "ai");
          const payload = { prompt, current_design: getDesignSnapshot() };

          try {
            const res = await fetch(CHAT_ENDPOINT, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(payload),
            });
            const data = await res.json();
            thinking.remove();

            // display human-readable text if present
            const humanText = data.message || data.text || "AI responded";
            const wrapper = addMessage(humanText, "ai");

            // if backend returned design JSON, show Apply button
            const design =
              data.design ||
              (typeof data.data === "object" && data.data) ||
              null;
            if (design) {
              const btn = document.createElement("button");
              btn.className = "btn primary";
              btn.textContent = "Apply";
              btn.style.marginTop = "8px";
              btn.addEventListener("click", () => {
                applyDesign(design);
                addMessage("AI design applied", "ai");
              });
              wrapper.appendChild(btn);
            }
          } catch (err) {
            thinking.remove();
            console.error(err);
            addMessage(
              "Error contacting server: " + (err.message || err),
              "ai"
            );
          }
        }

        /* -------------------- Node & DOM rendering -------------------- */
        function createNode(data) {
          const id = data.id || uuid("n");
          const node = Object.assign(
            {
              id,
              name: "Component",
              logo: "🧩",
              color: "#6d28d9",
              tech: [],
              desc: "",
              x: 120 + Object.keys(nodes).length * 24,
              y: 80 + Object.keys(nodes).length * 18,
            },
            data
          );
          nodes[id] = node;
          renderAll();
          postSaveDesignDebounced();
          return id;
        }

        function renderAll() {
          // clear nodes & labels but keep svg for links
          qa(".node").forEach((n) => n.remove());
          qa(".link-label").forEach((l) => l.remove());
          // render nodes
          Object.values(nodes).forEach(renderNode);
          drawLinks();
          drawMinimap();
        }

        function renderNode(node) {
          const el = document.createElement("div");
          el.className = "node";
          el.dataset.id = node.id;
          el.style.left = node.x * scale + "px";
          el.style.top = node.y * scale + "px";
          el.style.background = node.color;
          // adjust text color for contrast
          const textColor = getContrastColor(node.color);
          el.style.color = textColor;

          el.innerHTML = `
        <div class="row">
          <div class="leftmeta">
            <div class="icon" style="color:${textColor}">${escapeHtml(
            node.logo
          )}</div>
            <div style="display:flex;flex-direction:column">
              <div class="title" style="color:${textColor}">${escapeHtml(
            node.name
          )}</div>
              <div class="desc" style="color:${textColor};opacity:.9">${escapeHtml(
            node.desc || ""
          )}</div>
            </div>
          </div>
          <div style="position:relative"><div class="menu">⋯</div></div>
        </div>
        <div class="chips">${(node.tech || [])
          .map(
            (t) =>
              `<div class="chip" title="${escapeHtml(t)}">${escapeHtml(
                t
              )}</div>`
          )
          .join("")}</div>
        <div class="dot top" data-dot="top" title="connect top"></div>
        <div class="dot right" data-dot="right" title="connect right"></div>
        <div class="dot bottom" data-dot="bottom" title="connect bottom"></div>
        <div class="dot left" data-dot="left" title="connect left"></div>
      `;

          // menu actions
          const menuBtn = el.querySelector(".menu");
          const menu = document.createElement("div");
          menu.className = "menu-list";
          menu.innerHTML = `<button data-act="edit">Edit</button><button data-act="duplicate">Duplicate</button><button data-act="detach">Detach</button><button data-act="delete">Delete</button>`;
          el.appendChild(menu);
          menuBtn.addEventListener("click", (e) => {
            menu.classList.toggle("show");
            e.stopPropagation();
          });
          document.addEventListener("click", () =>
            qa(".menu-list").forEach((m) => m.classList.remove("show"))
          );

          menu.querySelectorAll("button").forEach((b) =>
            b.addEventListener("click", (ev) => {
              const act = b.dataset.act;
              handleNodeAction(node.id, act);
              menu.classList.remove("show");
              ev.stopPropagation();
            })
          );

          // chip remove click
          el.querySelectorAll(".chip").forEach((c) =>
            c.addEventListener("click", (ev) => {
              ev.stopPropagation();
              const t = c.textContent;
              nodes[node.id].tech = (nodes[node.id].tech || []).filter(
                (x) => x !== t
              );
              renderAll();
              postSaveDesignDebounced();
            })
          );

          // dot click -> linking
          el.querySelectorAll(".dot").forEach((d) =>
            d.addEventListener("click", (ev) => {
              ev.stopPropagation();
              const dot = d.dataset.dot;
              onDotClick(node.id, dot);
            })
          );

          // drag
          el.addEventListener("mousedown", (ev) => {
            if (
              ev.target.closest(".menu") ||
              ev.target.closest(".menu-list") ||
              ev.target.classList.contains("dot")
            )
              return;
            dragState = {
              id: node.id,
              sx: ev.clientX,
              sy: ev.clientY,
              ox: node.x,
              oy: node.y,
              el,
            };
            el.style.cursor = "grabbing";
            el.style.transform = "scale(1.02)";
            ev.preventDefault();
          });

          document.addEventListener("mousemove", (ev) => {
            if (!dragState) return;
            // translate pixel movement into canvas units (scale)
            const dx = (ev.clientX - dragState.sx) / scale;
            const dy = (ev.clientY - dragState.sy) / scale;
            const nx = Math.max(0, dragState.ox + dx);
            const ny = Math.max(0, dragState.oy + dy);
            nodes[dragState.id].x = nx;
            nodes[dragState.id].y = ny;
            // update DOM pos
            dragState.el.style.left = nx * scale + "px";
            dragState.el.style.top = ny * scale + "px";
            drawLinks();
            drawMinimap();
          });

          document.addEventListener("mouseup", () => {
            if (dragState) {
              dragState.el.style.cursor = "grab";
              dragState.el.style.transform = "";
              dragState = null;
              doAutoSaveDebounced();
            }
          });

          canvas.appendChild(el);
        }

        /* -------------------- connectors -------------------- */
        function onDotClick(nodeId, dot) {
          const pos = connectorPos(nodeId, dot);
          if (!linkingState) {
            linkingState = { nodeId, dot, startPos: pos };
            createTempPath(pos.x, pos.y, pos.x + 1, pos.y + 1);
            const moveHandler = (e) => {
              const rect = canvas.getBoundingClientRect();
              const mx = (e.clientX - rect.left + canvas.scrollLeft) / scale;
              const my = (e.clientY - rect.top + canvas.scrollTop) / scale;
              updateTempPath(
                linkingState.startPos.x,
                linkingState.startPos.y,
                mx,
                my
              );
            };
            const escHandler = (e) => {
              if (e.key === "Escape") cancelLinking();
            };
            window.addEventListener("mousemove", moveHandler);
            window.addEventListener("keydown", escHandler);
            linkingState._moveHandler = moveHandler;
            linkingState._escHandler = escHandler;
          } else {
            // finish link
            const from = linkingState;
            const to = { nodeId, dot };
            if (from.nodeId === to.nodeId && from.dot === to.dot) {
              cancelLinking();
              return;
            }
            // ask for label on the connection
            const label = prompt(
              "Label for connection (e.g., HTTP, Events, Reads/Writes):",
              ""
            );
            links.push({ id: uuid("l"), from, to, label: label || "" });
            cancelLinking();
            renderAll();
            postSaveDesignDebounced();
          }
        }
        function cancelLinking() {
          if (linkingState) {
            if (linkingState._moveHandler)
              window.removeEventListener(
                "mousemove",
                linkingState._moveHandler
              );
            if (linkingState._escHandler)
              window.removeEventListener("keydown", linkingState._escHandler);
          }
          linkingState = null;
          removeTempPath();
        }
        function createTempPath(x1, y1, x2, y2) {
          removeTempPath();
          const p = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "path"
          );
          p.setAttribute("class", "temp-path");
          p.setAttribute("d", straightishPath(x1, y1, x2, y2));
          p.setAttribute("stroke", "#cdb3ff");
          p.setAttribute("stroke-width", "1.6");
          p.setAttribute("fill", "none");
          p.setAttribute("stroke-dasharray", "6 6");
          linksSvg.appendChild(p);
          tempPath = p;
        }
        function updateTempPath(x1, y1, x2, y2) {
          if (!tempPath) return;
          tempPath.setAttribute("d", straightishPath(x1, y1, x2, y2));
        }
        function removeTempPath() {
          if (tempPath) {
            tempPath.remove();
            tempPath = null;
          }
        }

        // mostly straight with slight curve near ends
        function straightishPath(x1, y1, x2, y2) {
          // simple: straight line unless dx small -> small bezier near ends
          const dx = x2 - x1;
          const dy = y2 - y1;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < 40) {
            // small arc
            const mx = (x1 + x2) / 2,
              my = (y1 + y2) / 2;
            return `M ${x1} ${y1} Q ${mx + 8} ${my + 8} ${x2} ${y2}`;
          }
          // else small curvature proportional to distance
          const cx = x1 + dx * 0.5 + (dy > 0 ? 20 : -20);
          const cy = y1 + dy * 0.5 + (dx > 0 ? -12 : 12);
          return `M ${x1} ${y1} Q ${cx} ${cy} ${x2} ${y2}`;
        }

        /* -------------------- draw links and labels -------------------- */
        function drawLinks() {
          // clear svg and labels
          linksSvg.innerHTML = "";
          qa(".link-label").forEach((l) => l.remove());
          // add defs
          const defs = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "defs"
          );
          defs.innerHTML = `<marker id="arrowhead" viewBox="0 0 10 10" refX="9" refY="5" markerWidth="6" markerHeight="6" orient="auto"><path d="M 0 0 L 10 5 L 0 10 z" fill="${getLinkColor()}"/></marker>`;
          linksSvg.appendChild(defs);

          links.forEach((link) => {
            const f = connectorPos(link.from.nodeId, link.from.dot);
            const t = connectorPos(link.to.nodeId, link.to.dot);
            if (!f || !t) return;
            // path
            const path = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "path"
            );
            path.setAttribute("d", straightishPath(f.x, f.y, t.x, t.y));
            path.setAttribute("stroke", getLinkColor());
            path.setAttribute("stroke-width", "1.6");
            path.setAttribute("fill", "none");
            path.setAttribute("marker-end", "url(#arrowhead)");
            path.setAttribute("stroke-linecap", "round");
            path.style.cursor = "pointer";
            path.addEventListener("click", (e) => {
              e.stopPropagation();
              if (confirm("Delete this connection?")) {
                links = links.filter((l) => l.id !== link.id);
                drawLinks();
                postSaveDesignDebounced();
              }
            });
            linksSvg.appendChild(path);

            // label: midpoint of path bounding box
            const bbox = path.getBBox();
            const mx = bbox.x + bbox.width / 2;
            const my = bbox.y + bbox.height / 2;
            const label = document.createElement("div");
            label.className = "link-label";
            label.textContent = link.label || "";
            label.style.left = mx * scale + "px";
            label.style.top = my * scale + "px";
            label.addEventListener("dblclick", () => {
              const v = prompt("Edit connection label:", link.label || "");
              if (v !== null) {
                link.label = v;
                drawLinks();
                postSaveDesignDebounced();
              }
            });
            document.body.appendChild(label);
          });
        }

        function getLinkColor() {
          return document.body.classList.contains("theme-light")
            ? "#333333"
            : "#ffffff";
        }

        /* compute connector absolute positions in canvas coordinates */
        function connectorPos(nodeId, dot) {
          const el = qa(`.node[data-id="${nodeId}"]`)[0];
          const node = nodes[nodeId];
          if (!el || !node) return null;
          const rect = el.getBoundingClientRect();
          const canvasRect = canvas.getBoundingClientRect();
          // calculate position relative to canvas scroll and scale
          const x0 = (rect.left - canvasRect.left + canvas.scrollLeft) / scale;
          const y0 = (rect.top - canvasRect.top + canvas.scrollTop) / scale;
          const w = rect.width / scale,
            h = rect.height / scale;
          if (dot === "top") return { x: x0 + w / 2, y: y0 };
          if (dot === "bottom") return { x: x0 + w / 2, y: y0 + h };
          if (dot === "left") return { x: x0, y: y0 + h / 2 };
          if (dot === "right") return { x: x0 + w, y: y0 + h / 2 };
          return { x: x0 + w / 2, y: y0 + h / 2 };
        }

        /* -------------------- node actions -------------------- */
        function handleNodeAction(nodeId, action) {
          const node = nodes[nodeId];
          if (!node) return;
          if (action === "edit") openEditNode(nodeId);
          if (action === "duplicate") {
            const copy = Object.assign(
              {},
              { ...node },
              {
                id: uuid("n"),
                x: node.x + 28,
                y: node.y + 18,
                name: node.name + " (copy)",
              }
            );
            createNode(copy);
          }
          if (action === "detach") {
            links = links.filter(
              (l) => l.from.nodeId !== nodeId && l.to.nodeId !== nodeId
            );
            drawLinks();
            postSaveDesignDebounced();
          }
          if (action === "delete") {
            if (confirm("Delete node?")) {
              delete nodes[nodeId];
              links = links.filter(
                (l) => l.from.nodeId !== nodeId && l.to.nodeId !== nodeId
              );
              renderAll();
              postSaveDesignDebounced();
            }
          }
        }

        /* -------------------- edit modal -------------------- */
        function openEditNode(nodeId) {
          editingNodeId = nodeId;
          const node = nodes[nodeId];
          nodeName.value = node.name;
          nodeColor.value = node.color || "#6d28d9";
          // logos
          qa("#logoGrid button").forEach((b) => b.classList.remove("selected"));
          qa("#logoGrid button").forEach((b) => {
            if (b.textContent === node.logo) b.classList.add("selected");
          });
          // techs
          qa("#techGrid .tech-item").forEach((el) =>
            el.classList.remove("selected")
          );
          qa("#techGrid .tech-item").forEach((el) => {
            if (node.tech.includes(el.dataset.tech))
              el.classList.add("selected");
          });
          editModal.style.display = "flex";
        }

        saveNodeBtn.addEventListener("click", () => {
          const name = nodeName.value.trim() || "Component";
          const color = nodeColor.value;
          const logoBtn = qa("#logoGrid button.selected")[0];
          const logo = logoBtn ? logoBtn.textContent : "🧩";
          const techs = qa("#techGrid .tech-item.selected").map(
            (x) => x.dataset.tech
          );
          if (editingNodeId) {
            nodes[editingNodeId].name = name;
            nodes[editingNodeId].color = color;
            nodes[editingNodeId].logo = logo;
            nodes[editingNodeId].tech = techs;
            editModal.style.display = "none";
            editingNodeId = null;
            renderAll();
            postSaveDesignDebounced();
          } else {
            createNode({ name, color, logo, tech: techs });
            editModal.style.display = "none";
            postSaveDesignDebounced();
          }
        });
        cancelNodeBtn.addEventListener("click", () => {
          editModal.style.display = "none";
          editingNodeId = null;
        });

        /* -------------------- quick add & FAB & more list -------------------- */
        quickAddBtn.addEventListener("click", () => {
          const t =
            quickAddSelect.value ||
            quickAddSelect.options[quickAddSelect.selectedIndex].text;
          if (!t) return alert("Choose a node type");
          // auto-open modal with name prefilled
          openNewNodeModal(t);
        });

        function openNewNodeModal(pref) {
          editingNodeId = null;
          nodeName.value = pref || "";
          nodeColor.value = "#6d28d9";
          qa("#logoGrid button").forEach((b) => b.classList.remove("selected"));
          qa("#techGrid .tech-item").forEach((el) =>
            el.classList.remove("selected")
          );
          editModal.style.display = "flex";
        }

        /* FAB */
        fab.addEventListener("click", (e) => {
          // toggle menu
          if (fabMenu.style.display === "flex") {
            fabMenu.style.display = "none";
            return;
          }
          fabMenu.innerHTML = "";
          const quick = [
            "Frontend",
            "Backend",
            "Database",
            "Cache",
            "API Gateway",
          ];
          quick.forEach((name) => {
            const b = document.createElement("button");
            b.textContent = name;
            b.addEventListener("click", () => {
              openNewNodeModal(name);
              fabMenu.style.display = "none";
            });
            fabMenu.appendChild(b);
          });
          const more = document.createElement("button");
          more.textContent = "More…";
          more.addEventListener("click", () => {
            fabMenu.style.display = "none";
            openMoreModal();
          });
          fabMenu.appendChild(more);
          fabMenu.style.display = "flex";
        });

        function openMoreModal() {
          moreModal.style.display = "flex";
          moreList.innerHTML = "";
          const many = [
            "Load Balancer",
            "Message Queue",
            "Auth Service",
            "Logging Service",
            "Metrics",
            "CDN",
            "Scheduler",
            "Worker",
            "Batch Job",
            "CI/CD",
            "GraphQL",
            "WebSocket",
            "Notification Service",
            "Search Service",
            "Edge Proxy",
            "Secrets Manager",
          ];
          many.forEach((name) => {
            const b = document.createElement("button");
            b.textContent = name;
            b.className = "btn";
            b.style.width = "100%";
            b.addEventListener("click", () => {
              openNewNodeModal(name);
              moreModal.style.display = "none";
            });
            moreList.appendChild(b);
          });
        }
        moreClose.addEventListener(
          "click",
          () => (moreModal.style.display = "none")
        );

        /* populate logo and tech grids for modal */
        function renderLogoGrid() {
          logoGrid.innerHTML = "";
          LOGOS.forEach((l) => {
            const b = document.createElement("button");
            b.textContent = l;
            b.style.padding = "6px";
            b.style.borderRadius = "8px";
            b.addEventListener("click", () => {
              qa("#logoGrid button").forEach((x) =>
                x.classList.remove("selected")
              );
              b.classList.add("selected");
            });
            logoGrid.appendChild(b);
          });
        }
        function renderTechGrid() {
          techGrid.innerHTML = "";
          TECHS.forEach((t) => {
            const el = document.createElement("div");
            el.className = "tech-item";
            el.dataset.tech = t;
            el.style.padding = "6px";
            el.style.borderRadius = "8px";
            el.style.border = "1px solid rgba(255,255,255,0.04)";
            el.style.cursor = "pointer";
            el.textContent = t;
            el.addEventListener("click", () => el.classList.toggle("selected"));
            techGrid.appendChild(el);
          });
        }
        renderLogoGrid();
        renderTechGrid();

        /* -------------------- save / export / recenter / zoom -------------------- */
        function getDesignSnapshot() {
          const nodesSnap = {};
          Object.keys(nodes).forEach((k) => {
            const n = nodes[k];
            nodesSnap[k] = {
              id: n.id,
              name: n.name,
              color: n.color,
              logo: n.logo,
              tech: n.tech,
              desc: n.desc,
              x: Math.round(n.x),
              y: Math.round(n.y),
            };
          });
          const linksSnap = links.map((l) => ({
            id: l.id,
            from: l.from,
            to: l.to,
            label: l.label,
          }));
          return { nodes: nodesSnap, links: linksSnap };
        }

        async function postSaveDesign() {
          const payload = getDesignSnapshot();
          setStatus("Saving...");
          try {
            const res = await fetch(SAVE_ENDPOINT, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(payload),
            });
            const data = await res.json();
            // accept either {success:true} or {ok:true} or true
            if (data === true || data.success || data.ok) setStatus("Saved");
            else setStatus("Saved (server returned non-ok)");
          } catch (err) {
            console.error(err);
            setStatus("Save failed");
          }
          setTimeout(() => setStatus("Ready"), 1200);
        }
        function postSaveDesignDebounced() {
          doAutoSaveDebounced();
        }

        saveBtn.addEventListener("click", () => {
          const payload = getDesignSnapshot();
          const blob = new Blob([JSON.stringify(payload, null, 2)], {
            type: "application/json",
          });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = "scurd_design.json";
          document.body.appendChild(a);
          a.click();
          a.remove();
          URL.revokeObjectURL(url);
        });

        exportBtn.addEventListener("click", async () => {
          // capture canvas area
          setStatus("Exporting image...");
          // temporarily remove widgets that shouldn't appear (modals handled)
          // use html2canvas on canvas element
          try {
            const img = await html2canvas(canvas, {
              backgroundColor: getComputedStyle(document.body).backgroundColor,
              scale: 1.6,
              useCORS: true,
            });
            const url = img.toDataURL("image/png");
            const a = document.createElement("a");
            a.href = url;
            a.download = "scurd_canvas.png";
            document.body.appendChild(a);
            a.click();
            a.remove();
            setStatus("Export complete");
          } catch (e) {
            console.error(e);
            setStatus("Export failed");
          }
          setTimeout(() => setStatus("Ready"), 1200);
        });

        recenterBtn.addEventListener("click", () => {
          const all = Object.values(nodes);
          if (all.length === 0) {
            canvas.scrollLeft = 0;
            canvas.scrollTop = 0;
            return;
          }
          let minX = Infinity,
            minY = Infinity,
            maxX = -Infinity,
            maxY = -Infinity;
          all.forEach((n) => {
            minX = Math.min(minX, n.x);
            minY = Math.min(minY, n.y);
            maxX = Math.max(maxX, n.x);
            maxY = Math.max(maxY, n.y);
          });
          const canvasRect = canvas.getBoundingClientRect();
          const centerX = (minX + maxX) / 2;
          const centerY = (minY + maxY) / 2;
          canvas.scrollLeft = Math.max(
            0,
            centerX * scale - canvasRect.width / 2
          );
          canvas.scrollTop = Math.max(
            0,
            centerY * scale - canvasRect.height / 2
          );
          drawMinimap();
        });

        zoomInBtn.addEventListener("click", () => setScale(scale + 0.15));
        zoomOutBtn.addEventListener("click", () => setScale(scale - 0.15));

        function setScale(newScale) {
          scale = Math.max(0.5, Math.min(2.5, newScale));
          // update node DOM positions/sizes
          qa(".node").forEach((el) => {
            const id = el.dataset.id;
            if (!nodes[id]) return;
            el.style.left = nodes[id].x * scale + "px";
            el.style.top = nodes[id].y * scale + "px";
            el.style.transform = `scale(${scale})`;
            el.style.transformOrigin = "0 0";
          });
          linksSvg.style.transform = `scale(${scale})`;
          linksSvg.style.transformOrigin = "0 0";
          drawLinks();
          drawMinimap();
        }

        /* -------------------- minimap -------------------- */
        function drawMinimap() {
          const ctx = minimapCanvas.getContext("2d");
          const w = minimapCanvas.width;
          const h = minimapCanvas.height;
          ctx.clearRect(0, 0, w, h);
          // background
          ctx.fillStyle = "rgba(0,0,0,0.12)";
          ctx.fillRect(0, 0, w, h);
          const all = Object.values(nodes);
          if (all.length === 0) return;
          let minX = Infinity,
            minY = Infinity,
            maxX = -Infinity,
            maxY = -Infinity;
          all.forEach((n) => {
            minX = Math.min(minX, n.x);
            minY = Math.min(minY, n.y);
            maxX = Math.max(maxX, n.x + 180);
            maxY = Math.max(maxY, n.y + 120);
          });
          const bw = Math.max(1, maxX - minX);
          const bh = Math.max(1, maxY - minY);
          const margin = 8;
          const sx = (w - margin * 2) / bw,
            sy = (h - margin * 2) / bh;
          const mScale = Math.min(sx, sy);
          all.forEach((n) => {
            const rx = margin + (n.x - minX) * mScale;
            const ry = margin + (n.y - minY) * mScale;
            ctx.fillStyle = n.color || "#6d28d9";
            ctx.fillRect(
              rx,
              ry,
              Math.max(6, 40 * mScale),
              Math.max(4, 24 * mScale)
            );
          });
          // view rect
          const canvasRect = canvas.getBoundingClientRect();
          const viewX = canvas.scrollLeft / scale;
          const viewY = canvas.scrollTop / scale;
          const viewW = canvasRect.width / scale;
          const viewH = canvasRect.height / scale;
          const rvx = margin + (viewX - minX) * mScale;
          const rvy = margin + (viewY - minY) * mScale;
          ctx.strokeStyle = "rgba(255,255,255,0.9)";
          ctx.lineWidth = 1;
          ctx.strokeRect(rvx, rvy, viewW * mScale, viewH * mScale);
        }

        minimapCanvas.addEventListener("click", (e) => {
          const rect = minimapCanvas.getBoundingClientRect();
          const mx = e.clientX - rect.left;
          const my = e.clientY - rect.top;
          const all = Object.values(nodes);
          if (all.length === 0) return;
          let minX = Infinity,
            minY = Infinity,
            maxX = -Infinity,
            maxY = -Infinity;
          all.forEach((n) => {
            minX = Math.min(minX, n.x);
            minY = Math.min(minY, n.y);
            maxX = Math.max(maxX, n.x + 180);
            maxY = Math.max(maxY, n.y + 120);
          });
          const bw = Math.max(1, maxX - minX);
          const bh = Math.max(1, maxY - minY);
          const margin = 8;
          const sx = (minimapCanvas.width - margin * 2) / bw,
            sy = (minimapCanvas.height - margin * 2) / bh;
          const mScale = Math.min(sx, sy);
          const cx = (mx - margin) / mScale + minX;
          const cy = (my - margin) / mScale + minY;
          const canvasRect = canvas.getBoundingClientRect();
          canvas.scrollLeft = Math.max(0, cx * scale - canvasRect.width / 2);
          canvas.scrollTop = Math.max(0, cy * scale - canvasRect.height / 2);
          drawMinimap();
        });

        /* -------------------- panning & mouse wheel zoom -------------------- */
        canvas.addEventListener("mousedown", (e) => {
          if (e.target === canvas) {
            isPanning = true;
            panStart = {
              x: e.clientX + canvas.scrollLeft,
              y: e.clientY + canvas.scrollTop,
            };
            canvas.style.cursor = "grabbing";
          }
        });
        window.addEventListener("mousemove", (e) => {
          if (isPanning) {
            canvas.scrollLeft = panStart.x - e.clientX;
            canvas.scrollTop = panStart.y - e.clientY;
            drawMinimap();
          }
        });
        window.addEventListener("mouseup", () => {
          if (isPanning) {
            isPanning = false;
            canvas.style.cursor = "auto";
          }
        });

        // mouse wheel zoom (Ctrl+wheel modifies zoom)
        canvas.addEventListener(
          "wheel",
          (e) => {
            if (e.ctrlKey) {
              e.preventDefault();
              const delta = e.deltaY > 0 ? -0.08 : 0.08;
              // zoom around mouse cursor
              const rect = canvas.getBoundingClientRect();
              const mouseX =
                (e.clientX - rect.left + canvas.scrollLeft) / scale;
              const mouseY = (e.clientY - rect.top + canvas.scrollTop) / scale;
              const oldScale = scale;
              setScale(scale + delta);
              // adjust scroll to keep focus
              canvas.scrollLeft = Math.max(
                0,
                mouseX * scale - (e.clientX - rect.left)
              );
              canvas.scrollTop = Math.max(
                0,
                mouseY * scale - (e.clientY - rect.top)
              );
              drawMinimap();
            }
          },
          { passive: false }
        );

        /* -------------------- apply design from backend -------------------- */
        function applyDesign(design) {
          if (!design) return;
          nodes = {};
          links = [];
          const dn = design.nodes || design;
          // support both object keyed by id or array
          if (Array.isArray(dn)) {
            dn.forEach((n, i) =>
              createNode({
                id: n.id || uuid("n"),
                name: n.name || n.id || "node" + i,
                color: n.color || "#6d28d9",
                logo: n.logo || "🧩",
                tech: n.tech || [],
                desc: n.desc || "",
                x: n.x || 80 + i * 20,
                y: n.y || 80 + i * 20,
              })
            );
          } else {
            Object.keys(dn).forEach((k, i) => {
              const n = dn[k];
              createNode({
                id: k,
                name: n.name || k,
                color: n.color || "#6d28d9",
                logo: n.logo || "🧩",
                tech: n.tech || [],
                desc: n.description || n.desc || "",
                x: n.x || 80 + i * 30,
                y: n.y || 80 + i * 20,
              });
            });
          }
          const dl = design.links || design.connections || design.edges || [];
          dl.forEach((c) => {
            if (typeof c === "string") {
              const [a, b] = c.split("->").map((s) => s.trim());
              if (a && b)
                links.push({
                  id: uuid("l"),
                  from: { nodeId: a, dot: "right" },
                  to: { nodeId: b, dot: "left" },
                  label: "",
                });
            } else if (c.from && c.to)
              links.push({
                id: uuid("l"),
                from: { nodeId: c.from, dot: c.fromDot || "right" },
                to: { nodeId: c.to, dot: c.toDot || "left" },
                label: c.label || "",
              });
          });
          renderAll();
          postSaveDesignDebounced();
        }

        /* -------------------- contrast util -------------------- */
        function getContrastColor(hex) {
          try {
            const c = (hex || "#000").replace("#", "");
            const r = parseInt(c.substring(0, 2), 16);
            const g = parseInt(c.substring(2, 4), 16);
            const b = parseInt(c.substring(4, 6), 16);
            const luminance = (0.2126 * r + 0.7152 * g + 0.0722 * b) / 255;
            return luminance > 0.55 ? "#000" : "#fff";
          } catch (e) {
            return "#fff";
          }
        }

        /* -------------------- initial sample nodes -------------------- */
        createNode({
          id: "frontend",
          name: "Frontend",
          logo: "🌐",
          color: "#6d28d9",
          tech: ["React", "Vite"],
          desc: "Client UI",
          x: 80,
          y: 60,
        });
        createNode({
          id: "api",
          name: "API Gateway",
          logo: "🛰️",
          color: "#0ea5a4",
          tech: ["FastAPI", "Nginx"],
          desc: "Public API",
          x: 520,
          y: 90,
        });
        createNode({
          id: "backend",
          name: "Backend",
          logo: "🧠",
          color: "#f97316",
          tech: ["Node.js"],
          desc: "Business logic",
          x: 360,
          y: 220,
        });
        createNode({
          id: "db",
          name: "Postgres",
          logo: "🗄️",
          color: "#0ea5a4",
          tech: ["Postgres"],
          desc: "Primary DB",
          x: 240,
          y: 380,
        });
        links.push({
          id: uuid("l"),
          from: { nodeId: "frontend", dot: "right" },
          to: { nodeId: "api", dot: "left" },
          label: "HTTP",
        });
        links.push({
          id: uuid("l"),
          from: { nodeId: "api", dot: "bottom" },
          to: { nodeId: "backend", dot: "top" },
          label: "Requests",
        });
        links.push({
          id: uuid("l"),
          from: { nodeId: "backend", dot: "bottom" },
          to: { nodeId: "db", dot: "left" },
          label: "Reads/Writes",
        });
        renderAll();

        /* -------------------- autosave POST -------------------- */
        async function postSaveDesign() {
          const payload = getDesignSnapshot();
          setStatus("Saving...");
          try {
            const res = await fetch(SAVE_ENDPOINT, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(payload),
            });
            // accept boolean true or {success:true}
            let ok = false;
            try {
              const json = await res.json();
              if (json === true || json.success || json.ok) ok = true;
            } catch (e) {
              /* ignore */
            }
            if (ok) setStatus("Saved");
            else setStatus("Saved (server returned non-ok)");
          } catch (err) {
            console.error(err);
            setStatus("Save failed");
          }
          setTimeout(() => setStatus("Ready"), 1300);
        }

        /* -------------------- theme toggle -------------------- */
        themeToggle.addEventListener("click", () => {
          if (document.body.classList.contains("theme-light")) {
            document.body.classList.remove("theme-light");
            themeToggle.textContent = "🌙";
          } else {
            document.body.classList.add("theme-light");
            themeToggle.textContent = "☀️";
          }
          drawLinks();
          drawMinimap();
        });

        /* -------------------- helpers & cleanup -------------------- */
        function postSaveDesignDebounced() {
          doAutoSaveDebounced();
        }
        function doAutoSaveDebounced() {
          if (autoSaveTimer) clearTimeout(autoSaveTimer);
          autoSaveTimer = setTimeout(
            () => postSaveDesign(),
            AUTO_SAVE_DEBOUNCE
          );
        }

        /* Prevent page selection during drag */
        window.addEventListener("selectstart", (e) => {
          if (dragState) e.preventDefault();
        });

        /* When window resizes, recompute */
        window.addEventListener("resize", () => {
          drawLinks();
          drawMinimap();
        });

        /* expose applyDesign for console if needed */
        window.applyDesign = applyDesign;
      })();
    </script>
  </body>
</html>
